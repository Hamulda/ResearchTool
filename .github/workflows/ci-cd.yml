name: CI/CD Pipeline for Azure App Service (Free Tier)

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  AZURE_CONTAINER_REGISTRY: ${{ secrets.AZURE_CONTAINER_REGISTRY }}
  AZURE_WEBAPP_NAME: ${{ secrets.AZURE_WEBAPP_NAME }}
  AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
  IMAGE_NAME: researchtool

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      # Pou≈æit√≠ Cosmos DB Emulator pro testy m√≠sto PostgreSQL
      cosmos-emulator:
        image: mcr.microsoft.com/cosmosdb/linux/azure-cosmos-emulator:latest
        ports:
          - 8081:8081
          - 10251:10251
          - 10252:10252
          - 10253:10253
          - 10254:10254
        env:
          AZURE_COSMOS_EMULATOR_PARTITION_COUNT: 2
          AZURE_COSMOS_EMULATOR_ENABLE_DATA_PERSISTENCE: false

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt

    - name: Set up test environment variables
      run: |
        echo "COSMOS_DB_ENDPOINT=https://localhost:8081" >> $GITHUB_ENV
        echo "COSMOS_DB_KEY=C2y6yDjf5/R+ob0N8A7Cgv30VRDJIWEHLM+4QDU5DE2nQ9nDuVTqobD4b8mGGyPMbIZnqyMsEcaGQy67XIw/Jw==" >> $GITHUB_ENV
        echo "GEMINI_API_KEY=test_key" >> $GITHUB_ENV
        echo "DAILY_COST_LIMIT=0.1" >> $GITHUB_ENV
        echo "ENABLE_TELEMETRY=false" >> $GITHUB_ENV

    - name: Wait for Cosmos DB Emulator
      run: |
        echo "Waiting for Cosmos DB Emulator to be ready..."
        timeout 60s bash -c 'until curl -k https://localhost:8081; do sleep 5; done' || echo "Emulator might not be fully ready, continuing with tests"

    - name: Run tests with pytest
      run: |
        pytest test_core_components.py -v --tb=short
        # Skipping integration tests that require real Cosmos DB

    - name: Upload test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: test-results
        path: test-*.xml

  build-and-push-to-acr:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    outputs:
      image-tag: ${{ steps.image-tag.outputs.tag }}

    steps:
    - uses: actions/checkout@v4

    - name: Generate image tag
      id: image-tag
      run: |
        TAG="$(date +%Y%m%d%H%M%S)-${GITHUB_SHA::7}"
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "Generated image tag: $TAG"

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Login to Azure Container Registry
      run: |
        az acr login --name ${{ env.AZURE_CONTAINER_REGISTRY }}

    - name: Build optimized Docker image for App Service
      run: |
        docker build \
          --tag ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }} \
          --tag ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}:latest \
          --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
          --build-arg VCS_REF=${GITHUB_SHA} \
          --build-arg VERSION=${{ steps.image-tag.outputs.tag }} \
          --target production \
          .

    - name: Push image to ACR
      run: |
        docker push ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }}
        docker push ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}:latest

    - name: Basic security scan
      run: |
        # Jednoduch√Ω scan bez external tools pro free tier
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
          -v $(pwd):/app \
          aquasec/trivy:latest image \
          --severity HIGH,CRITICAL \
          --exit-code 1 \
          ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ steps.image-tag.outputs.tag }} || echo "Security scan completed with warnings"

  deploy-to-app-service:
    needs: build-and-push-to-acr
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    environment:
      name: production
      url: https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net

    steps:
    - uses: actions/checkout@v4

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Deploy to Azure App Service
      uses: azure/webapps-deploy@v2
      with:
        app-name: ${{ env.AZURE_WEBAPP_NAME }}
        images: ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ needs.build-and-push-to-acr.outputs.image-tag }}

    - name: Configure App Service settings
      run: |
        echo "Configuring App Service application settings..."
        
        # Configure runtime settings
        az webapp config appsettings set \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --settings \
            WEBSITES_ENABLE_APP_SERVICE_STORAGE=false \
            WEBSITES_PORT=8000 \
            DOCKER_REGISTRY_SERVER_URL=https://${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io \
            DOCKER_REGISTRY_SERVER_USERNAME=${{ env.AZURE_CONTAINER_REGISTRY }} \
            DOCKER_REGISTRY_SERVER_PASSWORD=${{ secrets.ACR_PASSWORD }}

        # Configure application settings (secrets are managed separately)
        az webapp config appsettings set \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --settings \
            COSMOS_DB_ENDPOINT=${{ secrets.COSMOS_DB_ENDPOINT }} \
            COSMOS_DB_KEY=${{ secrets.COSMOS_DB_KEY }} \
            GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }} \
            DAILY_COST_LIMIT=${{ secrets.DAILY_COST_LIMIT }} \
            MAX_SOURCES=5 \
            TOKEN_BUDGET=400 \
            ENABLE_CACHE=true \
            CACHE_TTL_HOURS=72 \
            ENVIRONMENT=production \
            LOG_LEVEL=INFO

    - name: Restart App Service
      run: |
        echo "Restarting App Service to apply new settings..."
        az webapp restart \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AZURE_WEBAPP_NAME }}

    - name: Verify deployment health
      run: |
        echo "Waiting for App Service to restart..."
        sleep 45
        
        APP_URL="https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
        echo "Application URL: $APP_URL"
        
        # Health check with retry
        for i in {1..6}; do
          echo "Health check attempt $i/6..."
          
          if curl -f "$APP_URL/health" --max-time 30 --retry 2; then
            echo "‚úÖ Application is healthy!"
            break
          else
            echo "‚ùå Health check failed, waiting..."
            if [ $i -eq 6 ]; then
              echo "‚ùå Deployment health check failed after 6 attempts"
              echo "Checking App Service logs..."
              az webapp log tail --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AZURE_WEBAPP_NAME }} --timeout 30
              exit 1
            fi
            sleep 30
          fi
        done

    - name: Update deployment tags
      run: |
        # Tag the web app with deployment info
        az webapp update \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AZURE_WEBAPP_NAME }} \
          --set tags.version="${{ needs.build-and-push-to-acr.outputs.image-tag }}" \
               tags.deployment-date="$(date -u +'%Y-%m-%d %H:%M:%S UTC')" \
               tags.commit-sha="${GITHUB_SHA}" \
               tags.environment="production"

    - name: Notify deployment success
      if: success()
      run: |
        echo "üöÄ Deployment to Azure App Service successful!"
        echo "Application URL: https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net"
        echo "Health endpoint: https://${{ env.AZURE_WEBAPP_NAME }}.azurewebsites.net/health"
        echo "Image: ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ needs.build-and-push-to-acr.outputs.image-tag }}"

  cleanup-old-images:
    needs: deploy-to-app-service
    runs-on: ubuntu-latest
    if: always() && github.ref == 'refs/heads/main'

    steps:
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Cleanup old container images (keep latest 3)
      run: |
        echo "Keeping latest 3 images, removing older ones to save ACR storage..."
        
        # Get list of image tags (excluding 'latest') sorted by creation date
        OLD_TAGS=$(az acr repository show-tags \
          --name ${{ env.AZURE_CONTAINER_REGISTRY }} \
          --repository ${{ env.IMAGE_NAME }} \
          --orderby time_desc \
          --query '[3:].[name]' \
          --output tsv | grep -v latest || true)
        
        if [ ! -z "$OLD_TAGS" ]; then
          echo "Deleting old image tags: $OLD_TAGS"
          for tag in $OLD_TAGS; do
            if [ "$tag" != "latest" ] && [ ! -z "$tag" ]; then
              echo "Deleting tag: $tag"
              az acr repository delete \
                --name ${{ env.AZURE_CONTAINER_REGISTRY }} \
                --image ${{ env.IMAGE_NAME }}:$tag \
                --yes
            fi
          done
          echo "‚úÖ ACR cleanup completed"
        else
          echo "No old images to cleanup"
        fi
